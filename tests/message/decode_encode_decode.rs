use bytes::Bytes;
use dbus_message_parser::message::Message;
use std::cmp::Ordering;

fn decode_encode_decode(msg: &[u8]) {
    // Decode Bytes to message
    let bytes = Bytes::copy_from_slice(&msg[..]);
    let (msg_1, _) = Message::decode(bytes).unwrap();

    // Encode message to BytesMut
    let bytes = msg_1.encode().unwrap();

    // Decode message again
    let (msg_2, _) = Message::decode(bytes.freeze()).unwrap();

    // Check if it is equal
    if let Some(ordering) = msg_1.partial_cmp(&msg_2) {
        match ordering {
            Ordering::Equal => {}
            ordering => {
                panic!("\n{:?}\nleft:  {:?}\nright: {:?}", ordering, msg_1, msg_2);
            }
        }
    }
}

#[test]
fn msg_1() {
    let msg = b"\x6c\x02\x01\x01\x0a\x00\x00\x00\x01\x00\x00\x00\x3d\x00\x00\x00\x06\x01\x73\x00\
    \x05\x00\x00\x00\x3a\x31\x2e\x39\x38\x00\x00\x00\x05\x01\x75\x00\x01\x00\x00\x00\x08\x01\x67\
    \x00\x01\x73\x00\x00\x07\x01\x73\x00\x14\x00\x00\x00\x6f\x72\x67\x2e\x66\x72\x65\x65\x64\x65\
    \x73\x6b\x74\x6f\x70\x2e\x44\x42\x75\x73\x00\x00\x00\x00\x05\x00\x00\x00\x3a\x31\x2e\x39\x38\
    \x00";

    decode_encode_decode(&msg[..]);
}

#[test]
fn msg_2() {
    let msg = b"\x6c\x02\x01\x01\xec\x00\x00\x00\x60\x00\x00\x00\x36\x00\x00\x00\x06\x01\x73\x00\
    \x06\x00\x00\x00\x3a\x31\x2e\x31\x30\x35\x00\x00\x08\x01\x67\x00\x0a\x61\x7b\x73\x28\x62\x67\
    \x61\x76\x29\x7d\x00\x05\x01\x75\x00\x39\x01\x00\x00\x07\x01\x73\x00\x05\x00\x00\x00\x3a\x31\
    \x2e\x39\x39\x00\x00\x00\xe4\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x71\x75\x69\x74\x00\
    \x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
    \x0c\x00\x00\x00\x6e\x65\x77\x2d\x64\x6f\x63\x75\x6d\x65\x6e\x74\x00\x00\x00\x00\x00\x00\x00\
    \x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b\x00\x00\x00\x70\x72\
    \x65\x66\x65\x72\x65\x6e\x63\x65\x73\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
    \x00\x00\x00\x09\x00\x00\x00\x73\x68\x6f\x72\x74\x63\x75\x74\x73\x00\x00\x00\x01\x00\x00\x00\
    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x68\x65\x6c\x70\x00\x00\x00\
    \x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\
    \x00\x00\x61\x62\x6f\x75\x74\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\
    \x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x00\x6e\x65\x77\x2d\x77\x69\x6e\x64\x6f\x77\x00\x00\
    \x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

    decode_encode_decode(&msg[..]);
}

#[test]
fn msg_3() {
    let msg = b"\x6c\x04\x01\x01\x74\x00\x00\x00\xb8\x00\x00\x00\x76\x00\x00\x00\x01\x01\x6f\x00\
    \x10\x00\x00\x00\x2f\x6f\x72\x67\x2f\x67\x6e\x6f\x6d\x65\x2f\x64\x66\x65\x65\x74\x00\x00\x00\
    \x00\x00\x00\x00\x00\x02\x01\x73\x00\x0f\x00\x00\x00\x6f\x72\x67\x2e\x67\x74\x6b\x2e\x41\x63\
    \x74\x69\x6f\x6e\x73\x00\x08\x01\x67\x00\x16\x61\x73\x61\x7b\x73\x62\x7d\x61\x7b\x73\x76\x7d\
    \x61\x7b\x73\x28\x62\x67\x61\x76\x29\x7d\x00\x00\x00\x00\x00\x03\x01\x73\x00\x07\x00\x00\x00\
    \x43\x68\x61\x6e\x67\x65\x64\x00\x07\x01\x73\x00\x05\x00\x00\x00\x3a\x31\x2e\x38\x39\x00\x00\
    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x5c\x00\x00\x00\x00\x00\
    \x00\x00\x04\x00\x00\x00\x68\x65\x6c\x70\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x61\x62\x6f\x75\x74\x00\x00\x00\
    \x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\
    \x00\x71\x75\x69\x74\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\
    \x00\x00";

    decode_encode_decode(&msg[..]);
}

#[test]
fn msg_4() {
    let msg = b"\x6c\x01\x00\x01\x00\x00\x00\x00\xbd\x00\x00\x00\x8e\x00\x00\x00\x01\x01\x6f\x00\
    \x04\x00\x00\x00\x2f\x6f\x72\x67\x00\x00\x00\x00\x02\x01\x73\x00\x23\x00\x00\x00\x6f\x72\x67\
    \x2e\x66\x72\x65\x65\x64\x65\x73\x6b\x74\x6f\x70\x2e\x44\x42\x75\x73\x2e\x49\x6e\x74\x72\x6f\
    \x73\x70\x65\x63\x74\x61\x62\x6c\x65\x00\x00\x00\x00\x00\x06\x01\x73\x00\x1c\x00\x00\x00\x6f\
    \x72\x67\x2e\x66\x72\x65\x65\x64\x65\x73\x6b\x74\x6f\x70\x2e\x46\x69\x6c\x65\x4d\x61\x6e\x61\
    \x67\x65\x72\x31\x00\x00\x00\x00\x03\x01\x73\x00\x0a\x00\x00\x00\x49\x6e\x74\x72\x6f\x73\x70\
    \x65\x63\x74\x00\x00\x00\x00\x00\x00\x07\x01\x73\x00\x05\x00\x00\x00\x3a\x31\x2e\x38\x39\x00\
    \x00\x00";

    decode_encode_decode(&msg[..]);
}

#[test]
#[cfg(target_family = "unix")]
fn msg_5() {
    let fds = [1, 2];
    let msg = b"\x6c\x01\x00\x01\x08\x00\x00\x00\x00\x00\x00\x00\x68\x00\x00\x00\x01\x01\x6f\x00\
    \x0c\x00\x00\x00\x2f\x6f\x62\x6a\x65\x63\x74\x2f\x70\x61\x74\x68\x00\x00\x00\x00\x02\x01\x73\
    \x00\x11\x00\x00\x00\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x2e\x65\x78\x61\x6d\x70\x6c\x65\x00\
    \x00\x00\x00\x00\x00\x00\x03\x01\x73\x00\x06\x00\x00\x00\x4d\x65\x6d\x62\x65\x72\x00\x00\x06\
    \x01\x73\x00\x02\x00\x00\x00\x3a\x31\x00\x00\x00\x00\x00\x00\x08\x01\x67\x00\x02\x68\x68\x00\
    \x09\x01\x75\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00";
    let bytes = Bytes::copy_from_slice(&msg[..]);

    let (msg_1, offset, offset_fds) = Message::decode_with_fds(bytes, &fds[..]).unwrap();
    assert_eq!(offset_fds, fds.len());
    assert_eq!(msg.len(), offset);
    assert!(msg_1.has_unix_fds());

    let (bytes, fds_2) = msg_1.encode_with_fds().unwrap();
    let bytes = bytes.freeze();
    assert_eq!(&fds[..], &fds_2[..]);

    let (msg_2, offset_2, offset_fds_2) =
        Message::decode_with_fds(bytes.clone(), &fds_2[..]).unwrap();
    assert_eq!(offset_fds_2, fds_2.len());
    assert_eq!(bytes.len(), offset_2);
    assert_eq!(msg_2.get_unix_fds(), Some(2));

    // Check if it is equal
    if let Some(ordering) = msg_1.partial_cmp(&msg_2) {
        match ordering {
            Ordering::Equal => {}
            ordering => {
                panic!("\n{:?}\nleft:  {:?}\nright: {:?}", ordering, msg_1, msg_2);
            }
        }
    }
}
